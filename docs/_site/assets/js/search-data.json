{
  
  "0": {
    "title": "Primera aplicación",
    "content": "Primera aplicación . . Para esta primera aplicación utilizaremos los elementos TextView, Button y EditText . La aplicación tendrá el siguiente aspecto: . . El layout utilizado será el de por defecto ConstraintLayout . . Observa como está organizado el layout. Simplemente arrastra los puntos blancos donde quieras añadir una restricción. Haciendo ajustes en el diseñador se modificará automáticamente el fichero .xml. . Video ConstraintLayout: https://www.youtube.com/watch?v=Vf3_NqnG7bM . A continuación programamos los botones. Hemos puesto 3 botones de 3 formas diferentes. . Forma 1: Implementamos la interface View.OnClickListener . public class MainActivity extends AppCompatActivity implements View.OnClickListener{ . En esta forma deberemos configurar los listener del botón: . //listener forma1 boton1 = findViewById(R.id.buttonTipo1); boton1.setOnClickListener(this); . E implementar el método OnClick: . public void onClick(View v) { //Hago referencia al elemento que quiero capturar EditText campoTexto = findViewById(R.id.editText); //Cojo el texto String textoUsuario = campoTexto.getText().toString(); //Y lo muestro en una tostada Toast.makeText(this, textoUsuario, Toast.LENGTH_LONG).show(); } . En este caso al pulsar el botón llamamos hacemos una referencia, cojemos el texto y a continuación mostramos el texto en una tostada. . Forma 2: Definimos el método a llamar en el fichero .xml . Se crea un método cualquiera con la siguiente estructura: . public void forma2(View v) { //Tostada para comprobar que funciona Toast.makeText(this, &quot;Forma 2 de poner un botón&quot;, Toast.LENGTH_SHORT).show(); } . A continuación especificaremos el método creado en el atributo onClick del botón: . . Forma 3: Definir el listener y la referencia al botón a la vez. . De esta forma unicamente deberemos de copiar el siguiente código en el método onCreate de la Actividad: . //tercera forma de hacer un botón final Button boton3 = findViewById(R.id.buttonTipo3); boton3.setOnClickListener(new View.OnClickListener() { public void onClick(View v) { // Code here executes on main thread after user presses button Toast.makeText(MainActivity.this, &quot;No necesito implementar la interface&quot;, Toast.LENGTH_SHORT).show(); } }); . Todo el código está en: https://github.com/Manuel-Ag/PMD_19-20/tree/master/Primera_aplicacion .",
    "url": "http://localhost:4000/PMD_19-20/docs/primer_trimestre_android/2019-09-25-primera-aplicacion/",
    "relUrl": "/docs/primer_trimestre_android/2019-09-25-primera-aplicacion/"
  }
  ,"1": {
    "title": "Método FindViewByID",
    "content": "Método FindViewById . Para acceder a una vista (botones, cajas de texto, checkboxes, etc.) deberemos primeramente de referenciar ese elemento: . //En este ejemplo un textView. TextView myTextView = findViewById(R.id.textViewNombre); . De esta forma podremos acceder a sus atribunos, asignar un listener, cambiar la visibilidad, etc. Por ejemplo, si quisieramos acceder al texto de ese elemento deberíamos de escribir: . //En este ejemplo un textView. TextView myTextView = findViewById(R.id.textViewNombre); String cadena = myTextView.getText().toString(); . Recuerda que aunque en la paleta del diseñador tengamos muchos nombres diferentes, las cajas de texto en las que el usuario puede escribir son un EditText, como se puede ver en el árbol de componetes de la siguiente imagen: . . En el primer proyecto se puede ver también un ejemplo de esto: https://github.com/Manuel-Ag/PMD_19-20/tree/master/Primera_aplicacion .",
    "url": "http://localhost:4000/PMD_19-20/docs/primer_trimestre_android/2019-09-26-metodo-findviewbyid/",
    "relUrl": "/docs/primer_trimestre_android/2019-09-26-metodo-findviewbyid/"
  }
  ,"2": {
    "title": "Fichero Manifest",
    "content": "Fichero Manifest . El fichero Manifest es uno de los ficheros más importantes en un proyecto con Android Studio. . . Si abrimos el fichero podemos encontrar la siguiente información: . . Aquí podremos cambiar varias cosas de nuestra aplicación, como por ejemplo: . El icono de la aplicación (en el emulador que utilizamos necesitaremos cambiar el redondo, aunque se deben cambiar ambos) | La etiqueta del programa | El estilo de la aplicación | Permisos requeridos | Y, sobre todo, los componentes que utilizaremos en nuestra aplicación (actividades, sevicios, etc…) los cuales deberán ser declarados en este fichero si deseamos que funcione el programa correctamente | . Por otro lado, si pulsamos en Merged Manifest en la pestaña inferior izquierda: . . Tendremos más opciones para configurar. Simplemente deberemos comprobar el color de la línea e ir al fichero correspondiente para modificar el campo (a los ficheros se acceden arriba a la derecha según el código de color). Es una forma rápida de cambiar por ejemplo el API mínima para la que se va a desarrollar. . Para más información: https://github.com/Manuel-Ag/PMD_19-20/tree/master/Primera_aplicacion .",
    "url": "http://localhost:4000/PMD_19-20/docs/primer_trimestre_android/2019-10-02-manifest/",
    "relUrl": "/docs/primer_trimestre_android/2019-10-02-manifest/"
  }
  ,"3": {
    "title": "Ejemplo RadioButton y Checkbox",
    "content": "Ejemplo RadioButton y Checkbox . Ejemplo de clase: https://github.com/Manuel-Ag/PMD_19-20/tree/master/RadioButtonyCheckBox . En este ejemplo hemos aprendido a utilizar los RadioButton y los CheckBox, tanto accediendo únicamente al valor seleccionado como añadiendo un listener a la vista. . Para acceder a la selección del radioButton con un botón: . public void mostrarValores(View v) { String texto; RadioButton radioButton; //Referencia al RadioGroup RadioGroup radioGroup = findViewById(R.id.radioGroupEquipos); //Obtengo la id del radioButton que está seleccionado por el usuario int id = radioGroup.getCheckedRadioButtonId(); //switch según el id seleccionado switch (id){ case R.id.radioButtonReal: Toast.makeText(this, &quot;Hala Madrid!&quot;, Toast.LENGTH_SHORT).show(); break; case R.id.radioButtonAtletico: Toast.makeText(this, &quot;Aupa Atleti&quot;, Toast.LENGTH_SHORT).show(); break; case R.id.radioButtonZaragoza: Toast.makeText(this, &quot;Viva Zaragoza&quot; + comprobarCheckBox(), Toast.LENGTH_SHORT).show(); break; } } . Si queremo añadir un listener que reaccione cuando el usuario cambie la selección, tenemos que implementar la interface correspondiente: . implements RadioGroup.OnCheckedChangeListener . Añadir el listener al componente: . RadioGroup radioGroup = findViewById(R.id.radioGroupEquipos); radioGroup.setOnCheckedChangeListener(this); . E implementar la funcionalidad del método: . public void onCheckedChanged(RadioGroup group, int checkedId) { //Referencio el radioButton seleccionado RadioButton radioButton = findViewById(checkedId); //Imprimir texto del radioButon seleccionado Toast.makeText(this, radioButton.getText().toString(), Toast.LENGTH_SHORT).show(); } . Comprueba el ejemplo de GitHub y comprueba la similitud de este ejemplo de RadioButton en el caso de los CheckBox. .",
    "url": "http://localhost:4000/PMD_19-20/docs/primer_trimestre_android/2019-10-04-ejemplo_radio_check/",
    "relUrl": "/docs/primer_trimestre_android/2019-10-04-ejemplo_radio_check/"
  }
  ,"4": {
    "title": "Compatibilidad entre distintos idiomas",
    "content": "Compatibilidad entre distintos idiomas . Ejemplo de clase: https://github.com/Manuel-Ag/PMD_19-20/tree/master/Directorio_values . Es hora de quitar los warnings que teníamos hasta ahora en el diseñador: . . Para ello, únicamente deberemos definir en el fichero strings.xml de la carpeta values las cadenas que utilizará nuestro programa, por ejemplo el texto de nuestros dos botones: . &lt;resources&gt; &lt;string name=&quot;app_name&quot;&gt;Name application&lt;/string&gt; &lt;string name=&quot;btn_aceptar&quot;&gt;Accept&lt;/string&gt; &lt;string name=&quot;btn_cancelar&quot;&gt;Cancel&lt;/string&gt; &lt;/resources&gt; . A continuación, en las vistas que muestren texto, se deberá realizar una referencia al fichero strings.xml utilizando como primer caracter @: . . Los warnings relativos al texto hardcoded deberían de desaparecer. . Ya tenemos nuestra aplicación casi preparada para soportar varios idiomas. Únicamente falta un paso; crear otro fichero strings.xml para cualquier otro idioma soportado por nuestra aplicación. Simplemente deberemos hacer click derecho en la carpeta res y a continuación New&gt;Android resource file. Nos mostrará la siguiente ventana: . . Observa que podemos añadir diferentes restricciones. Nos centraremos en las de idioma. Selecciona Locale y pulsa la flecha doble para añadir, a continuación seleccionamos el idioma español de cualquier región (observa como el Directory name va variando según añadimos parámetros). Al finalizar se mostrará una estructura como la siguiente: . . La clave estará en replicar las cadenas definidas en el fichero strings.xml del inicio en el fichero strings.xml del idioma seleccionado, traduciendo el texto pero manteniendo el nombre de la cadena a la que hacemos referencia en el botón. . &lt;resources&gt; &lt;string name=&quot;app_name&quot;&gt;Nombre aplicación&lt;/string&gt; &lt;string name=&quot;btn_aceptar&quot;&gt;Aceptar&lt;/string&gt; &lt;string name=&quot;btn_cancelar&quot;&gt;Cancelar&lt;/string&gt; &lt;/resources&gt; . De esta forma Android automáticamente seleccionará el fichero con los recursos correspondientes al idioma seleccionado, en este caso el español. Cuando cambiemos el idioma del sistema operativo a español, la aplicación cambiará también de idioma si tiene recursos para ese idioma específico. Es una buena práctica de programación que siempre definiamos las cadenas en un fichero .xml aunque solo tengamos compatibilidad con un idioma. . Continuando con el ejemplo de clase, podrás observar que también se cambia la imagen del ImageView. Esto es porque también podremos crear una carpeta de imágenes según idioma, región, características del dispositivo, etc., al igual que con el fichero strings.xml. En este caso, comprueba la estructura real del proyecto, seleccionando la vista Project (arriba izquierda): . . Al igual que para la carpeta values, para la carpeta drawable hemos creado su versión para español. Para crear una carpeta simplemente haz click derecho en la carpeta res y a continuación en New&gt;Android Resource Directory: . . Los dos recursos deben de tener el mismo nombre, ya que será el que se utilizar para referenciarlo desde el atributo de la vista (el formato puede ser distinto). . Con todo esto ya sabemos como hacer una aplicación que muestre unos textos e imágenes dependiendo del idioma seleccionado en el sistema operativo Android. . Ejemplo de youtube: https://www.youtube.com/watch?v=ffjLi4Cwg1k .",
    "url": "http://localhost:4000/PMD_19-20/docs/primer_trimestre_android/2019-10-09-multi-idioma/",
    "relUrl": "/docs/primer_trimestre_android/2019-10-09-multi-idioma/"
  }
  ,"5": {
    "title": "Ejemplo Switch e ImageView",
    "content": "Ejemplo Switch e ImageView . Ejemplo de clase: https://github.com/Manuel-Ag/PMD_19-20/tree/master/SwitcheImageView . . Este ejemplo lo podemos dividir en dos partes: . 1. Utilización de Switch y ToggleButton: . public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) { // podemos acceder a la id del ToggleButton pulsado en //caso de tener varios (comparar con R.id.ToggleButton) int id = buttonView.getId(); Toast.makeText(this, &quot;Pulsado: &quot; + id + &quot; a &quot; + isChecked, Toast.LENGTH_SHORT).show(); } . Observa como se puede obtener el estado (isChecked) y la id del elemento que se ha pulsado. En caso de querer comprobar el botón que se ha pulsado simplemente podríamos compararlo con R.id.nombreSwitch. . 2. Cambio de imagen tanto en un ImageView como en un ImageButton. En este caso nos hemos apoyado de un botón. Al pulsarlo vemos que se ejecuta: . public void imageButton(View v) { ImageView imageView = findViewById(R.id.imageView); ImageButton imageButton = findViewById(R.id.imageButton); if (isSonic) { imageView.setImageResource(R.drawable.knuckles); imageButton.setImageResource(android.R.drawable.star_big_off); isSonic = false; } else { imageView.setImageResource(R.drawable.sonic); imageButton.setImageResource(android.R.drawable.star_big_on); isSonic = true; } } . Ten en cuenta que los recursos que se acceden mediante android.R. son recursos que vienen incluidos en la instalación de Android Studio. . Por último, observa que modificar en ambos la imagen resulta sencillo. En este caso controlamos si está una imagen u otra y las rotamos. .",
    "url": "http://localhost:4000/PMD_19-20/docs/primer_trimestre_android/2019-10-09-switch-imageview/",
    "relUrl": "/docs/primer_trimestre_android/2019-10-09-switch-imageview/"
  }
  ,"6": {
    "title": "Layouts",
    "content": "Layouts . En la asignatura utilizaremos los layouts que no estén legacy en Android Studio (los que estén en este apartado se consideran anticuados, siendo posible el uso de opciones mejores). . . En realidad utilizaremos únicamente 4 layouts: . ConstraintLayout: El creado por defecto en una actividad y el que más hemos utilizado hasta ahora. | LinearLayout: Tanto horizontal como vertical, únicamente cambia el atributo correspondiente. | FrameLayout: Contiene solo un elemento. | TableLayout: Para organizar los elementos en filas y columnas. Por ejemplo: | . . Observa en la imagen que, aunque en realidad TableLayout organiza los elementos en filas y columnas, podemos hacer que ocupen más de un hueco (en horizontal), o que se estiren en todo el espacio disponible. Para ello pondemos utilizar los siguientes atributos: . layout_span: Permite ocupar más de una columna a un elemento. | layout_weight: Si el valor es distinto del valor por defecto, permite “estirar” el componente dependiendo del peso dentro del layout, el cual corresponde tanto al valor propio como al de los demás elementos con el que comparte el espacio. | gravity en el layout o layout_gravity en una vista: Permite cambiar el punto de referencia desde el que se empiezan a ordenar los elementos dentro del layout, siendo por defecto arriba e izquierda. Este atributo se puede cambiar desde el layout para cambiar todos los elementos dentro de él o desde cada vista para cambiar el comportamiento únicamente de esa elemento. Este efecto es más apreciable en, por ejemplo, un LinearLayout en el que sobre espacio y los componentes puedan empezar a ordenarse desde otro lado. Ejemplo: | . . Este es el comportamiento al modificar estos atributos en TableLayout, siendo también válidos en otros layouts como se ha podido comprobar. Ten en cuenta que un layout puede contener a su vez otros layouts, por lo que el uso de estos atributos tendrán un comportamiento parecido con las diferentes vistas dentro del layout, como por ejemplo botones, campos de texto, editText, etc. . Durante el transcurso de la asignatura los iremos utilizando. Por ahora, intenta añadirlos a tu proyecto y comprobar cómo se ordenan las vistas en su interior, cambiando atributos e intentado que se ajusten a los diferentes tamaños. . Algunos links útiles: . https://developer.android.com/reference/android/widget/FrameLayout | https://developer.android.com/guide/topics/ui/layout/grid | https://developer.android.com/guide/topics/ui/layout/linear | .",
    "url": "http://localhost:4000/PMD_19-20/docs/primer_trimestre_android/2019-10-16-layout/",
    "relUrl": "/docs/primer_trimestre_android/2019-10-16-layout/"
  }
  ,"7": {
    "title": "Recorrido de un TableLayout",
    "content": "Recorrido de un TableLayout . Esta vez vamos a intentar añadir botones mediante código en tiempo de ejecución. . Ejemplo realizado en clase: https://github.com/Manuel-Ag/PMD_19-20/tree/master/RecorridoContenedor . En el ejemplo hay implementados tres métodos: . mostrarTableRows(): Accede a los TableRow del TableLayout. | . private void mostrarTableRows() { TableRow tableRow; View view; TableLayout tableLayout = findViewById(R.id.tableLayout); for (int i = 0; i &lt; tableLayout.getChildCount(); i++) { //Hacemos cast porque sabemos su tipo tableRow = (TableRow) tableLayout.getChildAt(i); //también podría funcionar //view = tableLayout.getChildAt(i); //Compruebo si realmente tengo acceso Log.i(&quot;Prueba&quot;, tableRow.toString()); } } . mostrarVistas(): Muestra las vistas que hay dentro cada TableRow. | . private void mostrarVistas() { TableRow tableRow; View view; TableLayout tableLayout = findViewById(R.id.tableLayout); for (int i = 0; i &lt; tableLayout.getChildCount(); i++) { //Hacemos cast porque sabemos su tipo tableRow = (TableRow) tableLayout.getChildAt(i); //Recorremos los tableRow for (int j = 0; j &lt; tableRow.getChildCount(); j++) { //Como no sabemos el tipo de vista, lo guardo en un tipo View view = tableRow.getChildAt(j); Log.i(&quot;Prueba&quot;, view.toString()); } } } . anadirBotones(): Añade botones en tiempo de ejecución aunque, podría ser cualquier tipo de vista. | . private void anadirBotones() { TableRow tableRow; View view; TableLayout tableLayout = findViewById(R.id.tableLayout); for (int i = 0; i &lt; tableLayout.getChildCount(); i++) { //Hacemos cast porque sabemos su tipo tableRow = (TableRow) tableLayout.getChildAt(i); //Creamos un botón Button button = new Button(this); button.setText(&quot;Texto&quot;); //Generamos Id button.setId(View.generateViewId()); //Añadimos el listener a cada botón button.setOnClickListener(this); //Asignamos una etiqueta button.setTag(&quot;boton&quot; + i); //Añadimos botón tableRow.addView(button); } } . Por último, se ha añadido un nuevo TableRow en el TableLayout: . //Para ello, creo un tableRow TableRow tr_head = new TableRow(this); //Y lo añado al tableLayout tableLayout.addView(tr_head); //Añadimos un botón a la fila creada Button button = new Button(this); button.setText(&quot;Texto&quot;); button.setId(View.generateViewId()); tr_head.addView(button); . Con todo ello, tendremos el siguiente resultado: . . Como se puede observar, se ha introducido un botón en cada fila. Si quisieramos más de uno en cada TableRow, ¿cómo podrías introducir varios botones en la misma fila?. Observa que en cada iteración del bucle se tiene acceso al TableRow correspondiente, pero únicamente se añade un botón… .",
    "url": "http://localhost:4000/PMD_19-20/docs/primer_trimestre_android/2019-10-17-recorrido-contenedor/",
    "relUrl": "/docs/primer_trimestre_android/2019-10-17-recorrido-contenedor/"
  }
  ,"8": {
    "title": "Ejemplo sencillo de Fragment",
    "content": "Ejemplo sencillo de Fragment . En este ejemplo vamos a cambiar dónde creamos la interfaz de usuario, pasando de la Actividad principal a un Fragmento. . Enlace al proyecto: https://github.com/Manuel-Ag/PMD_19-20/tree/master/EjemplosencilloFragment | Enlace a la documentación: https://developer.android.com/guide/components/fragments?hl=es-419 | . El código para crear un Fragmento es sencillo, únicamente debemos hacer que una clase herede de Fragment: . public class Fragmento1 extends Fragment { @Nullable @Override public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) { return inflater.inflate(R.layout.fragmento1, container, false); } } . Como se puede apreciar, se ha creado un fichero fragmento1.xml, pasándose como parámetro al método inflate() de la clase LayoutInflater. Será en este fichero donde se añadan las vistas. . . Observa cómo en nuestro ejemplo en realidad hay 3 ficheros con el mismo nombre. En este caso se ha aplicado lo aprendido en el ejemplo de aplicación multi-lenguaje; simplemente se ha cambiado los criterios para la utilización de un fichero u otro, cambiando el idioma por la orientación del teléfono (portrait o landscape). . Por último, simplemente añade un contenedor de tipo fragment al fichero .xml correspondiente al layout principal. Esto hará que este fragmento se cargue dentro de este layout (puedes observarlo tanto en el diseñador como en el pripio fichero .xml). . .",
    "url": "http://localhost:4000/PMD_19-20/docs/primer_trimestre_android/2019-10-18-ejemplo-fragment/",
    "relUrl": "/docs/primer_trimestre_android/2019-10-18-ejemplo-fragment/"
  }
  ,"9": {
    "title": "Diálogos",
    "content": "Diálogos . Un diálogo tiene el siguiente aspecto: . . Aunque realmente es muy configurable, se puede añadir una lista en vez de texto, o incluso un diseño personalizado. . Enlace a la documentación: https://developer.android.com/guide/topics/ui/dialogs?hl=es-419 | Enlace al proyecto: https://github.com/Manuel-Ag/PMD_19-20/tree/master/Dialogos | . Como se puede apreciar, la clase DialogFragment hereda de Fragment, por lo que parte de lo aprendido se puede aplicar a los diálogos. Para empezar, simplemente debemos de heredar de la clase DialogFragment: . public class Dialogo extends DialogFragment { Respuesta respuesta; @NonNull @Override public Dialog onCreateDialog(@Nullable Bundle savedInstanceState) { //Utilizamos esta clase para crear el diálogo AlertDialog.Builder builder = new AlertDialog.Builder(getActivity()); builder.setTitle(&quot;Título diálogo&quot;); builder.setMessage(&quot;Este será el mensaje a mostrar&quot;); //Botón positivo builder.setPositiveButton(&quot;Aceptar&quot;, new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialog, int which) { //Llamo a la implementación en MainActivity.java respuesta.onRespuesta(&quot;A&quot;); } }); builder.setNegativeButton(&quot;Cancelar&quot;, new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialog, int which) { Log.i(&quot;Prueba&quot;, &quot;funciono&quot;); } }); return builder.create(); } } . La clase AlertDialog permite configurar el diálgo con el aspecto que deseemos. En este caso hemos utilizado únicamente dos botones, añadidos mediante los métodos setPositiveButton() y setNegativeButton() de la clase AlertDialog.Builder, aunque sería posible incluir un tercer botón con setNeutralButton(). Para ver la utilización de estos métodos podemos consultar la documentación de la clase AlertDialog.Builder: https://developer.android.com/reference/android/app/AlertDialog.Builder.html?hl=es-419 . Para recibir información de vuelta a la actividad principal se ha implementado la solución propuesta en la documentación oficial: https://developer.android.com/guide/topics/ui/dialogs?hl=es-419 a partir de la sección Cómo pasar eventos de vuelta al host del diálogo. Para ello se propone utilizar callbacks. . Se han seguido los siguientes pasos: . 1. Se añade el siguiente código a la clase Dialogo: . @Override public void onAttach(@NonNull Context context) { super.onAttach(context); respuesta = (Respuesta) context; } /** * Declaración de la interface que se ejecutará al pulsar los botones */ public interface Respuesta { //Los métodos en las interfaces solo están declarados public void onRespuesta(String s); } . Como se puede observar, se implementa el método onAttach(), el cual asigna valor a respuesta y se define la interface Respuesta(), con el método onRespuesta(). . 2. Se llama al método de la interface: Observa cómo cuando se pulsa un botón se llama al método de la interface Respuesta, aun no habiéndose implementado. . builder.setPositiveButton(&quot;Aceptar&quot;, new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialog, int which) { //Llamo a la implementación en MainActivity.java respuesta.onRespuesta(&quot;A&quot;); } }); . 3. Implementa la interface en la clase principal: Esto obligará a implementar los métodos de la interface, los cuales serán llamados cuando se pulse en el botón: . public class MainActivity extends AppCompatActivity implements Dialogo.Respuesta{ ... @Override public void onRespuesta(String s) { Toast.makeText(this, s, Toast.LENGTH_SHORT).show(); } } . En este caso muestra en una tostada el valor recibido por parámetro. . Ver también: . Ejemplo con más configuraciones de AlertDialog: https://github.com/Manuel-Ag/PMD_19-20/tree/master/Dialogos2 | https://es.wikipedia.org/wiki/Callback_(inform%C3%A1tica) | http://codictados.com/android-callbacks/ | http://sourcenotas.blogspot.com/2009/07/callback-en-java.html | .",
    "url": "http://localhost:4000/PMD_19-20/docs/primer_trimestre_android/2019-10-21-dialogos/",
    "relUrl": "/docs/primer_trimestre_android/2019-10-21-dialogos/"
  }
  ,"10": {
    "title": "RecyclerView",
    "content": "RecyclerView . Pasos para implementar un RecyclerView: . 1.Crea tu propia clase adaptador MyAdapter: . public class MyAdapter extends RecyclerView.Adapter&lt;MyAdapter.MyViewHolder&gt; { ... } . El propio entorno te indicará que métodos y clases debes de implementar. . 2.Para darle funcionalidad a los botones, define los listener en la subclase: . public class MyViewHolder extends RecyclerView.ViewHolder implements View.OnClickListener { ... } . 3.También definimos la interface para el callback: . public interface ItemClickListener { void onItemClick(View view, int position); } . 4.En la actividad principal es donde deberemos de utilizar nuestro adaptador: . protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); recyclerView = (RecyclerView) findViewById(R.id.recyclerView); // use this setting to improve performance if you know that changes // in content do not change the layout size of the RecyclerView recyclerView.setHasFixedSize(true); // use a linear layout manager layoutManager = new LinearLayoutManager(this); recyclerView.setLayoutManager(layoutManager); // specify an adapter (see also next example) mAdapter = new MyAdapter(myDataSet); mAdapter.setClickListener(this); recyclerView.setAdapter(mAdapter); } . 5.Y, obviamente, implementar la interface para el callback: . public class MainActivity extends AppCompatActivity implements MyAdapter.ItemClickListener { ... public void onItemClick(View view, int position) { Log.d(&quot;prueba&quot;, &quot;You clicked &quot; + mAdapter.getItem(position) + &quot; on row number &quot; + position); } } . Para modificar el contenido de la lista tenemos a nuestra disposición varios métodos para notificar el cambio. En el ejemplo en GitHub se ha implementado un botón que añade un elemento a la lista: . public void boton(View v) { myDataSet.add(&quot;Añadido&quot;); mAdapter.notifyDataSetChanged(); } . En este caso simplemente se ha añadido un elemento al final; se ha modificado myDataSet y se ha notificado a mAdapter el cambio con el método notifyDataSetChanged() . Existen otros métodos para notificar otros tipos de cambios como: . notifyItemInserted() : INsertar un item. | notifyItemRangeInserted() : Insertar varios items. | notifyItemRemoved() : Eliminar un item. | notifyItemRangeRemoved() : Eliminar varios items. | clear() : Vaciar lista. | notifyDataSetChanged() : Cambio de todos los elementos. | notifyItemChanged() : Actualizar un item. | notifyItemMoved() : Mover solo un item. | . Visita los siguientes enlaces para ver un ejemplo en funcionamiento: . GitHub: https://github.com/Manuel-Ag/PMD_19-20/tree/master/RecyclerView | Documentación oficial: https://developer.android.com/guide/topics/ui/layout/recyclerview | Ejemplo paso a paso en StackOverflow: https://stackoverflow.com/questions/40584424/simple-android-recyclerview-example/40584425#40584425 | Ejemplo añadir nuevos elementos en StackOverflow: https://stackoverflow.com/questions/31367599/how-to-update-recyclerview-adapter-data/48959184#48959184 | .",
    "url": "http://localhost:4000/PMD_19-20/docs/primer_trimestre_android/2019-10-28-recyclerView/",
    "relUrl": "/docs/primer_trimestre_android/2019-10-28-recyclerView/"
  }
  ,"11": {
    "title": "Action Bar",
    "content": "Action Bar . En este ejemplo vamos a añadir un menú al Action Bar de una actividad (barra superior) . 1. Creamos el directorio menu: . . 2. Creamos un fichero menu.xml en el directorio recién creado: . . 3. Crearemos el diseño: . . Recuerda algunos atributos importantes para el comportamiento de algunos elementos de la interface: . . 4. Desde la actividad inflamos el menú implementado el siguiente método: . public boolean onCreateOptionsMenu(Menu menu) { MenuInflater inflater = getMenuInflater(); // Indicamos nuestro recurso menú anteriormente creado inflater.inflate(R.menu.menu, menu); return super.onCreateOptionsMenu(menu); } . 5. Y por último, comprobamos cuando el usuario ha pulsado alguna opción: . public boolean onOptionsItemSelected(@NonNull MenuItem item) { switch (item.getItemId()) { case R.id.item1: Toast.makeText(this, &quot;Se ha pulsado el item1&quot;, Toast.LENGTH_SHORT).show(); break; case R.id.item2: Toast.makeText(this, &quot;Se ha pulsado el item2&quot;, Toast.LENGTH_SHORT).show(); break; case R.id.item3: Toast.makeText(this, &quot;Se ha pulsado el item3&quot;, Toast.LENGTH_SHORT).show(); break; case R.id.item4: Toast.makeText(this, &quot;Se ha pulsado el item4&quot;, Toast.LENGTH_SHORT).show(); break; } return super.onOptionsItemSelected(item); } . Visita los siguientes enlaces para ver un ejemplo en funcionamiento: . GitHub: https://github.com/Manuel-Ag/PMD_19-20/tree/master/MenuActionBar | Documentación oficial: https://developer.android.com/training/appbar?hl=es-419 | Ejemplo: https://www.sgoliver.net/blog/action-bar-en-android-i/ | .",
    "url": "http://localhost:4000/PMD_19-20/docs/primer_trimestre_android/2019-11-06-actionbar/",
    "relUrl": "/docs/primer_trimestre_android/2019-11-06-actionbar/"
  }
  ,"12": {
    "title": "Intents y filtros de intents",
    "content": "Intents y filtros de intents . Antes de nada, visita los siguientes enlaces: . Intents y filtros de intents: https://developer.android.com/guide/components/intents-filters.html?hl=es | Documentación de la clase Intent: https://developer.android.com/reference/android/content/Intent | . Intents . El primer proyecto que comentaremos es el relativo a envío de intents, tanto implícitos como explícitos. Proyecto: https://github.com/Manuel-Ag/PMD_19-20/tree/master/Intents. . . En este proyecto dividiremos los ejemplos en diferentes botones: . Botón Intent explícito: El primer intent lo utilizamos únicamente para lanzar otra actividad, sin ninguna otra funcionalidad. | . public void botonIntentExplicito(View v) { // Creamos el intent Intent intent = new Intent(this, Actividad2.class); // Lanzamos la segunda actividad startActivity(intent); } . Creamos el intent explícito y se envía el intent cuando se llama al método startActivity(). Este método enviará el intent a la actividad definida. . Botón Intent con putExtra(): Podemos enviar información adjunta al intent. Simplemente debemos especificar un identificador al campo y la información. | . public void botonIntentExplicitoPutExtra(View v) { // Creamos el intent Intent intent = new Intent(this, Actividad2.class); // Llamamos a putExtra() intent.putExtra(&quot;tag1&quot;, &quot;Contenido intent(1)&quot;); intent.putExtra(&quot;tag2&quot;, &quot;Contenido intent(2)&quot;); // Lanzamos la segunda actividad startActivity(intent); } . Para recuperar esa información en la actividad receptora, se recupera el intent enviado y se hace referencia a sus identificadores con el método get() correspondiente: . // Recupero el intent que ha lanzado esta actividad Intent intent = getIntent(); // Y su contenido String tag1 = intent.getStringExtra(&quot;tag1&quot;); String tag2 = intent.getStringExtra(&quot;tag2&quot;); . Botón Intent con respuesta: Cuando abrimos una actividad y esperamos una respuesta de esta, debemos de implementar algunos métodos más. Primero, el método que lanza el intent cambia a startActivityForResult(). Además, en este caso OPCION1 identifica al intent, lo cuál lo comprobaremos en la respuesta. | . Intent intent = new Intent(this, Actividad2.class); startActivityForResult(intent, OPCION1); . En la segunda actividad creada, se debe responder con: . public void botonAceptar(View v) { Intent intent = new Intent(); intent.putExtra(&quot;tag3&quot;, &quot;Hola&quot;); // Enviamos el intent al MainActivity.class y cerramos la actividad actual setResult(RESULT_OK, intent); finish(); } . El método setResult() envía el intent y el método finish() finaliza la actividad actual. setResult() tiene otro parámetro que indica si el código de respuesta es RESULT_OK u otro, el cuál podremos conocer en la primera actividad. . Para recuperar el intent desde la primera actividad deberemos de implementar: . protected void onActivityResult(int requestCode, int resultCode, @Nullable Intent data) { super.onActivityResult(requestCode, resultCode, data); switch (requestCode) { case OPCION1: if (resultCode == RESULT_OK) { Toast.makeText(this, &quot;Intent Opción 1: &quot; + data.getStringExtra(&quot;tag3&quot;), Toast.LENGTH_LONG).show(); } else Toast.makeText(this, &quot;Usuario ha cancelado&quot;, Toast.LENGTH_LONG).show(); break; } } . Observa como tenemos 3 parámetros: requestCode, resultCode y data. Corresponden respectivamente a OPCION1, RESULT_OK y al intent enviado en respuesta por la segunda actividad. En el ejemplo anterior se puede observar como podemos recuperar el contenido del intent, identificarlo y conocer el código de respuesta. . Botón Intent implícito HTTP: Los intent implícitos por el contrario son más fáciles de implementar. Por ejemplo, si queremos visitar una aplicación web únicamente es necesario definir el intent implícito y enviarlo. | . Intent intent = new Intent(); intent.setAction(Intent.ACTION_VIEW); //Parseamos a tipo Uri (la dirección debe de empezar por http: intent.setData(Uri.parse(editText.getText().toString())); startActivity(intent); . Es importante definir la acción y los datos del intent para que se nos dé a elegir el tipo de aplicación correcto. La cadena de dirección (URI) deberá de comenzar por http:. Esto es importante debido a que indica el tipo de contenido de ese intent. . El uso es parecido al del intent explícito, pero sin definir a quién va dirigido. Será el propio sistema operativo el que le dé a elegir al usuario la opción aplicación preferida. . Botón GPS: Otro ejemplo utilizando maps. | . Intent intent = new Intent(); intent.setAction(Intent.ACTION_VIEW); // Según lo definido en setData se abrirá una aplicación u otra intent.setData(Uri.parse(&quot;geo:41.6460036,-0.8884131&quot;)); startActivity(intent); . En este caso, la URI definida por setData() empezará por geo:. . Botón Email: Y por último, otro ejemplo con aplicaciones para enviar emails. Se abrirá un cliente de email con un email ya creado con los datos definidos en el intent, listo para ser enviado. | . Intent intent = new Intent(); intent.setType(&quot;*/*&quot;); intent.setData(Uri.parse(&quot;mailto:&quot;)); intent.setAction(Intent.ACTION_SENDTO); intent.putExtra(Intent.EXTRA_EMAIL, new String[]{&quot;direcasd@gads.com&quot;, &quot;adsf@gfas.com&quot;}); intent.putExtra(Intent.EXTRA_SUBJECT, &quot;Asunto&quot;); intent.putExtra(Intent.EXTRA_STREAM, &quot;Cuerpo&quot;); startActivity(intent); . Hay que tener en cuenta que para enviar emails desde el dispositivo se debe de haber configurado una cuenta de Gmail previamente. . Cada intent, según la especificación, debe de construirse con unas características. Para ello existen guías que muestran los más comunes: https://developer.android.com/guide/components/intents-common?hl=es-419 . Filtros de intents . Los filtros de intents ponen a nuestra aplicación en el lado contrario; como los receptores del intent, siempre que se defina en el componente un filtro de intent compatible que se ajuste a los parámetros del intent enviado. Será el usuario al que se le de la opción de seleccionar nuestra aplicación entre una lista. En nuestro ejemplo, haremos que la aplicación de fotos comparta una imagen y sea nuestra aplicación la que capture el intent y muestre la imagen. . . Pasos a seguir en el proyecto https://github.com/Manuel-Ag/PMD_19-20/tree/master/Intentfilter : . Instala la aplicación en el dipositivo y ciérrala. | Realiza una foto con la aplicación de fotos del dispositivo. | Abre una aplicación que permita visualizar fotos y compartirlas. En nuestro ejemplo utilizaremos la aplicación fotos. | Pulsa en el incono de compartir, a continuación selecciona nuestra aplicación. | Para implementar un filtro de intent, simplemente debemos de definir en el fichero manifiesto el filtro en un componente: . &lt;activity android:name=&quot;.MainActivity&quot;&gt; ... &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.SEND&quot; /&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;data android:mimeType=&quot;image/*&quot; /&gt; &lt;/intent-filter&gt; ... &lt;/activity&gt; . Un mismo componente puede tener más de un filtro. En este ejemplo nos centraremos en el de imágenes. . Los filtros pueden tener diferentes acciones, datos o tipos de datos. Para ver la construcción de filtros más comunes puedes visitar https://developer.android.com/guide/components/intents-common?hl=es-419 y ver varios ejemplos. Entre la lista se puede encontrar el de nuestra aplicación. . De esta forma, nuestra aplicación recibirá ese intent con los datos definidos. Será nuestra responsabilidad capturarlo: . Intent intent = getIntent(); // Acción String action = intent.getAction(); // Tipo mime String type = intent.getType(); Log.d(&quot;prueba&quot;, &quot;Action: &quot; + action + &quot; Tipo: &quot; + type); // Comprobamos la acción y que le tipo no es nulo if (Intent.ACTION_SEND.equals(action) &amp;&amp; type != null) { // En caso de ser texto plano (hay que definirlo en el Manifest.xml) if (&quot;text/plain&quot;.equals(type)) { } // En caso de ser imagen else if (type.startsWith(&quot;image/&quot;)) { ImageView imageView = findViewById(R.id.imageView); // Pasamos la dirección de la imagen Uri imageUri = (Uri) intent.getParcelableExtra(Intent.EXTRA_STREAM); imageView.setImageURI(imageUri); } } . Una vez recuperado el intent que lanzó nuestra actividad, podemos conocer la acción, el tipo, los datos, etc., para a continuación manejarlo como más convenga. En este caso, nos viene una URI con la dirección de una imagen, así que la usaremos para localizar la imágen y mostrarla en nuestra aplicación. . Ver también: . Tipos mime: https://developer.mozilla.org/es/docs/Web/HTTP/Basics_of_HTTP/MIME_types | .",
    "url": "http://localhost:4000/PMD_19-20/docs/primer_trimestre_android/2019-11-11-intents/",
    "relUrl": "/docs/primer_trimestre_android/2019-11-11-intents/"
  }
  ,"13": {
    "title": "Permisos",
    "content": "Permisos . Antes de nada, visita los siguientes enlaces: . Guía de permisos: https://developer.android.com/training/permissions/requesting?hl=es-419 | Listado de permisos: https://developer.android.com/guide/topics/security/permissions.html?hl=es-419 | Buenas prácticas: https://developer.android.com/training/permissions/usage-notes?hl=es-419 | . Cómo pedir permisos . La forma más fácil es utilizar la que se nos propone en la documentación: . 1. Declararlos en el fichero manifiesto. . ... &lt;uses-permission android:name=&quot;android.permission.READ_CONTACTS&quot;/&gt; ... . 2. Pedirlos en tiempo de ejecución (obligatorio a partir del API 23). . // Here, thisActivity is the current activity if (ContextCompat.checkSelfPermission(thisActivity, Manifest.permission.READ_CONTACTS) != PackageManager.PERMISSION_GRANTED) { // Permission is not granted // Should we show an explanation? if (ActivityCompat.shouldShowRequestPermissionRationale(thisActivity, Manifest.permission.READ_CONTACTS)) { // Show an explanation to the user *asynchronously* -- don&#39;t block // this thread waiting for the user&#39;s response! After the user // sees the explanation, try again to request the permission. } else { // No explanation needed; request the permission ActivityCompat.requestPermissions(thisActivity, new String[]{Manifest.permission.READ_CONTACTS}, MY_PERMISSIONS_REQUEST_READ_CONTACTS); // MY_PERMISSIONS_REQUEST_READ_CONTACTS is an // app-defined int constant. The callback method gets the // result of the request. } } else { // Permission has already been granted } . Código paso a paso . En el ejemplo anterior se siguen los siguientes pasos: . Comprueba si se tienen los permisos | . if (ContextCompat.checkSelfPermission(thisActivity, Manifest.permission.READ_CONTACTS) != PackageManager.PERMISSION_GRANTED) . En caso de no tenerlos, tenemos otra bifurcación | . if (ActivityCompat.shouldShowRequestPermissionRationale(thisActivity, Manifest.permission.READ_CONTACTS)) { // Vacío } else { ActivityCompat.requestPermissions(thisActivity, new String[]{Manifest.permission.READ_CONTACTS}, MY_PERMISSIONS_REQUEST_READ_CONTACTS); . El método shouldShowRequestPermissionRationale() sigue el siguiente esquema: . . Por lo que podremos saber si es la primera vez que al usuario se le pide el permiso o no. En caso de insistir al usuario en un permiso, podremos cambiar la funcionalidad al pedir ese permiso, como por ejemplo cambiar la forma de pedirlo, mostrar información adicional en un diálogo, pedir que el usuario lo active desde los ajustes, etc. . Cuando se acepta o deniega permisos se llamará al siguiente método: | . @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) { super.onRequestPermissionsResult(requestCode, permissions, grantResults); if (requestCode == MY_PERMISSIONS_REQUEST_READ_CONTACTS) Log.i(&quot;Prueba&quot;, &quot;Permisos: &quot; + Arrays.toString(permissions) + &quot; Estado:&quot; + Arrays.toString(grantResults)); } . De esta forma, podremos saber una vez se ha mostrado al usuario el cuadro de conceder permisos o no, las elecciones que ha tomado para cada permiso (llegan como parámetro en los arrays). . Esto, entre otras cosas, nos facilita saber si el usuario ha seleccionado la opción: no mostrar otra vez cuando se le pide un permiso. Puedes ver un ejemplo de esta implementación en el siguiente enlace: https://stackoverflow.com/questions/30719047/android-m-check-runtime-permission-how-to-determine-if-the-user-checked-nev . GitHub: https://github.com/Manuel-Ag/PMD_19-20/tree/master/Permisos | .",
    "url": "http://localhost:4000/PMD_19-20/docs/primer_trimestre_android/2019-11-13-permisos/",
    "relUrl": "/docs/primer_trimestre_android/2019-11-13-permisos/"
  }
  ,"14": {
    "title": "Broadcast Receiver y SMS",
    "content": "BroadcastReceiver y SMS . Antes de nada, visita los siguientes enlaces: . Ya hablamos anteriormente un poco de los receptores de emisiones: https://developer.android.com/guide/components/fundamentals?hl=es-419 | Guía Broadcast Receiver: https://developer.android.com/guide/components/broadcasts | . Primer ejemplo: Creación de un Broadcast Receiver . Proyecto: https://github.com/Manuel-Ag/PMD_19-20/tree/master/Broadcastreceiver . El Broadcast Receiver: Será el componente que se lance al recibir el mensaje. | . public class Receptor extends BroadcastReceiver { @Override public void onReceive(Context context, Intent intent) { Toast.makeText(context, &quot;SMS entrante&quot;, Toast.LENGTH_LONG).show(); } } . Declaración en fichero manifiesto o en tiempo de ejecución: Dependerá, como siempre, de la versión de Android (ver enlace sobre Broadcast Receiver). | . Receptor receptor = new Receptor(); IntentFilter filter = new IntentFilter(); filter.addAction(&quot;android.provider.Telephony.SMS_RECEIVED&quot;); this.registerReceiver(receptor, filter); . &lt;receiver android:name=&quot;.Receptor&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.provider.Telephony.SMS_RECEIVED&quot; /&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; . Segundo ejemplo: Envío y recepción de SMS . A continuación, veremos un ejemplo más completo en el que enviaremos y recuperaremos un SMS. Proyecto: https://github.com/Manuel-Ag/PMD_19-20/tree/master/RecibirSMS . El código para enviar un SMS es muy sencillo. Podemos hacerlo mediante un intent (no requiere permisos) o mediante SMSManager (requiere permisos). En este enlace puedes ver un ejemplo: https://www.tutorialspoint.com/android/android_sending_sms.htm . // SMS mediante la API SmsManager smsManager = SmsManager.getDefault(); smsManager.sendTextMessage(editText.toString(), null, &quot;sms message&quot;, null, null); // SMS mediante intent Uri uri = Uri.parse(&quot;smsto:&quot;+editText.toString()); Intent intent = new Intent(Intent.ACTION_SENDTO, uri); intent.putExtra(&quot;sms_body&quot;, &quot;The SMS text&quot;); startActivity(intent); . Para leer un SMS si será necesario pedir los permisos. Se puede leer el mensaje entrante mediante el siguiente código: . public void onReceive(Context context, Intent intent) { if (intent.getAction().equals(SMS_RECEIVED)) { Bundle bundle = intent.getExtras(); SmsMessage[] msgs = null; String origen = null; String msg = null; if (bundle != null) { Object[] pdu = (Object[]) bundle.get(&quot;pdus&quot;); msgs = new SmsMessage[pdu.length]; for (int i = 0; i &lt; msgs.length; i++) { String format = bundle.getString(&quot;format&quot;); msgs[i] = SmsMessage.createFromPdu((byte[])pdu[i], format); origen = msgs[i].getOriginatingAddress(); msg = msgs[i].getMessageBody(); } respuesta.onRecibeSMS(origen, msg); //Toast.makeText(context, &quot;Mensaje&quot;, Toast.LENGTH_SHORT).show(); Log.i(&quot;Prueba&quot;, &quot;Broadcast funciona&quot;); } } } . En el proyecto de GitHub además hemos implementado un callback. Como recordarás, ya lo utilizamos para los diálgos. Si necesitas un repaso puedes visitar el siguiente enlace: http://codictados.com/android-callbacks/ .",
    "url": "http://localhost:4000/PMD_19-20/docs/primer_trimestre_android/2019-11-18-broadcastreceiver/",
    "relUrl": "/docs/primer_trimestre_android/2019-11-18-broadcastreceiver/"
  }
  ,"15": {
    "title": "Content providers y acceso a los contactos",
    "content": "Content providers y acceso a los contactos . Guía sobre content providers: . https://developer.android.com/guide/topics/providers/content-providers?hl=es-419 | https://developer.android.com/guide/topics/providers/content-provider-basics?hl=es-419 | . GitHub: . Proyecto GitHub: https://github.com/Manuel-Ag/PMD_19-20/tree/master/Consultar_contactos | . Una vez estudiada la teoría tendremos una mejor comprensión de en qué consisten los content providers. Veamos un ejemplo en el que mostraremos los contactos de la agenda: . public void listarContactos(View v) { // Columnas a recuperar String proyeccion[] = {ContactsContract.Contacts._ID, ContactsContract.Contacts.DISPLAY_NAME, ContactsContract.Contacts.HAS_PHONE_NUMBER, ContactsContract.Contacts.PHOTO_ID}; // Filtros de la búsqeda String filtro = ContactsContract.Contacts.DISPLAY_NAME + &quot; like ?&quot;; // Nombres que contenga la &#39;a&#39; String arg_filtro[] = {&quot;%a%&quot;}; //Consulta de los contactos ContentResolver contentResolver = getContentResolver(); Cursor cur = contentResolver.query(ContactsContract.Contacts.CONTENT_URI, proyeccion, filtro, arg_filtro, null); // Al recorrer el cursor, recuperamos el resultado de la consulta if (cur.getCount() &gt; 0) { while (cur.moveToNext()) { // Recuperamos las 3 columnas, ID, DISPLAY_NAME y HAS_PHONE_NUMBER String id = cur.getString(cur.getColumnIndex(ContactsContract.Contacts._ID)); String name = cur.getString(cur.getColumnIndex(ContactsContract.Contacts.DISPLAY_NAME)); Log.i(&quot;Contactos&quot;, &quot;ID: &quot; + id + &quot; nombre: &quot; + name); // Si el contacto tiene algún número de teléfono, los mostramos todos if (Integer.parseInt(cur.getString(cur.getColumnIndex(ContactsContract.Contacts.HAS_PHONE_NUMBER))) &gt; 0) { // Realizamos otra consulta cambiado el filtro, cuando el ID del contacto es igual al ID de la tabla donde se encuentran los números de teléfono Cursor phones = contentResolver.query( ContactsContract.CommonDataKinds.Phone.CONTENT_URI, null, ContactsContract.CommonDataKinds.Phone.CONTACT_ID +&quot; = &quot;+ id, null, null); // Volvemos a recorrer un cursos while (phones.moveToNext()) { String telefono = phones.getString(phones.getColumnIndex(ContactsContract.CommonDataKinds.Phone.NUMBER)); Log.i(&quot;Contactos&quot; , telefono); } } } } } . El ejemplo se divide dos pasos: . 1. Consulta de todos los contactos de teléfono según un filtro, en este caso contactos que contenga la letra ‘a’. Se consulta la id, el nombre y si tiene o no algún teléfono. . // Columnas a recuperar String proyeccion[] = {ContactsContract.Contacts._ID, ContactsContract.Contacts.DISPLAY_NAME, ContactsContract.Contacts.HAS_PHONE_NUMBER, ContactsContract.Contacts.PHOTO_ID}; // Filtros de la búsqeda String filtro = ContactsContract.Contacts.DISPLAY_NAME + &quot; like ?&quot;; // Nombres que contenga la &#39;a&#39; String arg_filtro[] = {&quot;%a%&quot;}; //Consulta de los contactos ContentResolver contentResolver = getContentResolver(); Cursor cur = contentResolver.query(ContactsContract.Contacts.CONTENT_URI, proyeccion, filtro, arg_filtro, null); . Siempre se pueden poner a null los parámetros de los filtros para recuperar todos los contactos. . 2. Para los contactos que tienen teléfono, realizamos otra consulta en la tabla donde se almacenan esos datos. . ContactsContract.CommonDataKinds.Phone.CONTENT_URI, null, ContactsContract.CommonDataKinds.Phone.CONTACT_ID +&quot; = &quot;+ id, null, null); . Observa como comparamos la id de la primera consulta para recuperar ese contacto específicamente en la consulta de teléfonos. .",
    "url": "http://localhost:4000/PMD_19-20/docs/primer_trimestre_android/2019-11-19-content-provider/",
    "relUrl": "/docs/primer_trimestre_android/2019-11-19-content-provider/"
  }
  ,"16": {
    "title": "SQLite",
    "content": "SQLite . Proyecto GitHub: https://github.com/Manuel-Ag/PMD_19-20/tree/master/SQLite | . Ejemplo básico . En este ejemplo vamos a ver como podemos conectarnos a una base de datos y lanzar algunas consultas básicas: . 1. Conexión o creación de la base de datos. . public void conectarCrearBaseDatos(View v) { // Crear o conectarse a una base de datos existente db = openOrCreateDatabase(&quot;MiDB&quot;, Context.MODE_PRIVATE, null); } . 2. Primera consulta sobre esa conexión. Creación de una tabla. . public void crearTabla(View v) { // Creamos la base de datos si no existe db.execSQL(&quot;CREATE TABLE IF NOT EXISTS miTabla(atributo1 VARCHAR, atributo2 VARCHAR)&quot;); } . Simplemente debemos llamar a execSQL() para lanzar una consulta sobre la base de datos. . 3. Inserción de datos. . public void insertarDatos(View v) { // Lanzamos la consulta de insertado db.execSQL(&quot;INSERT INTO miTabla VALUES (&#39;Campo1&#39;, &#39;Campo2&#39;)&quot;); } . 4. Y consulta de los datos insertados. . public void listar(View v) { // rawQuery lanza la consulta SQL y devuelve un cursor al resultado Cursor c = db.rawQuery(&quot;SELECT * FROM miTabla&quot;, null); if (c.getCount() == 0) { Log.i(&quot;Resultado&quot;, &quot;No hay registros&quot;); } else { while(c.moveToNext()) Log.i(&quot;Resultado&quot;, c.getPosition() + &quot;. &quot; + c.getString(0) + &quot;, &quot; + c.getString(1)); } } . En este último paso utilizamos el método rawQuery(), el cual devolverá un cursor con los campos de la consulta SQL SELECT. Simplemente recorreremos el cursor y recuperaremos los campos según la posición, empezando por la posición 0. .",
    "url": "http://localhost:4000/PMD_19-20/docs/primer_trimestre_android/2019-11-24-sqlite/",
    "relUrl": "/docs/primer_trimestre_android/2019-11-24-sqlite/"
  }
  ,"17": {
    "title": "Servicios e hilos",
    "content": "En este ejemplo vamos a utilizar un sevicio que compruebe si la wifi está conectada no. . Proyecto: https://github.com/Manuel-Ag/PMD_19-20/tree/master/Servicios | . Antes de continuar visita https://developer.android.com/guide/components/services?hl=es-419 y revisa el contenido respecto a los tipos de servicios, ciclo de vida, métodos importantes, etc. . Para crear el programa se han seguido los siguientes pasos: . 1. Creación de una interface gráfica con dos botones que lancen y paren el servicio. . . public void arrancar(View v) { Intent intent = new Intent(this, WifiTest.class); startService(intent); } public void parar(View v) { Intent intent = new Intent(this, WifiTest.class); stopService(intent); } . Para crear y parar el servicio creamos un Intent y llamamos a startService() o stopService() respectivamente. . 2. La clase WifiTest es el servicio, por lo que hereda de Service . public class WifiTest extends Service { ... } . No olvides declarar el componente en el fichero Manifest . &lt;service android:name=&quot;.WifiTest&quot;&lt;/service&gt; . 3. Gestión del servicio: . public class WifiTest extends Service { private boolean enEjecucion = false; Tester tester; @Override public void onCreate() { Log.i(&quot;prueba&quot;, &quot;onCreate&quot;); } @Override public int onStartCommand(Intent intent, int flags, int startId) { if (!enEjecucion) { tester = new Tester(); tester.start(); enEjecucion = true; Log.i(&quot;prueba&quot;, &quot;arrancando&quot;); }else { Log.i(&quot;prueba&quot;, &quot;el sevicio ya estaba arrancado&quot;); } return START_STICKY; } @Override public IBinder onBind(Intent intent) { return null; } @Override public void onDestroy() { if(enEjecucion) tester.interrupt(); Log.i(&quot;prueba&quot;, &quot;servicio destruido&quot;); } . onBind() devuelve nulo ya que es un servicio no enlazado. | onStartCommand() será el método que se ejecute al lanzar el servicio. | Con la variable enEjecucion controlamos si el servicio ya ha sido lanzado con anterioridad. | La clase Tester es un hilo que se lanzará a la vez del servicio. | . 4. La clase Tester es la que incorpora la funcionalidad propia del servicio. . public boolean comprobarWifi() { ConnectivityManager connectivityManager = (ConnectivityManager) getApplicationContext() .getSystemService(Context.CONNECTIVITY_SERVICE); NetworkInfo networkInfo = connectivityManager .getNetworkInfo(ConnectivityManager.TYPE_WIFI); if (networkInfo.isConnected()) return true; return false; } . Desde el servicio se instanciará la clase y se ejecutará el hilo. Al parar el servicio también se parará el hilo. . @Override public void onDestroy() { if(enEjecucion) tester.interrupt(); Log.i(&quot;prueba&quot;, &quot;servicio destruido&quot;); } .",
    "url": "http://localhost:4000/PMD_19-20/docs/segundo_trimestre_android/2019-12-01-servicios-hilos/",
    "relUrl": "/docs/segundo_trimestre_android/2019-12-01-servicios-hilos/"
  }
  ,"18": {
    "title": "AsyncTask",
    "content": "En el ejemplo anterior utilizamos un hilo de ejecución independiente con la clase Thread. Android nos proporciona una formas más sencilla para trabajar con más hilos de ejecución. Es la clase AsyncTask. En nuestro ejemplo de uso haremos que otro hilo de ejecución cuente de 0 a 10 y lo muestre en un editText. . Proyecto GitHub: https://github.com/Manuel-Ag/PMD_19-20/tree/master/Asynctask | . 1. Creación de la clase anidada que hereda de AsyncTask: . // &lt;Parámetros, progreso y resultado&gt; public class Tarea extends AsyncTask&lt;Integer, Integer, Integer&gt; { ... } . Cuando heredemos de esta clase estamos heredando el método abastracto doInBackground() por lo que se nos obligará de importarlo. Será en este método donde se encuentre el código que se ejecute en otro hilo de ejecución distinto al principal. . Observa que se definen tres parámetros. Estos parámetros al ser definidos cambiarán la declaración de los métodos al ser implementados automáticamente. Corresponden a: . . Recuperado de: https://stackoverflow.com/questions/6053602/what-arguments-are-passed-into-asynctaskarg1-arg2-arg3 . 2. El código que se ejecutará en otro hilo de ejecución será el de dentro del método doInBackground(): . @Override protected Integer doInBackground(Integer... objects) { for (int i = 0; i &lt;= objects[0]; i++) { publishProgress(i,i*100/objects[0]); SystemClock.sleep(300); // Si cancelamos salimos del bucle if (isCancelled()) break; } return objects[0]; } . Como puedes observar, simplemente es un contador de 0 al número que se haya pasado por parámetro. En cada iteración paramos el hilo un corto periodo de tiempo y se llama a publishProgress() . Este método nos permitirá actualizar el estado del hilo cada vez que se llame desde el hilo principal de ejecución del programa: . @Override protected void onProgressUpdate(Integer... values) { editText.setText(values[0].toString()); progressBar.setProgress(values[1]); } . En nuestro ejemplo hemos utilizado un progressBar para mostrar el avance del hilo así como un editText donde poner el número actual. . Ten en cuenta que este método no se llamará si se cancela la ejecución: . public void cancelar(View v) { tarea.cancel(true); } . 3. También disponemos de métodos que se ejecutará antes y después del código definido en doInBackGround(), aunque estos serán ejecutados en el hilo principal del programa. . @Override protected void onPreExecute() { button.setText(&quot;Calculando...&quot;); } @Override protected void onPostExecute(Integer integer) { button.setText(&quot;Se ha sumado&quot; + integer + &quot;veces&quot;); } . 4. Con todo preparado, simplemente nos queda instanciar la clase y ejecutar: . tarea = new Tarea(); tarea.execute(Integer.parseInt(editText.getText().toString())); . La tarea se ejecutará hasta que termine o cancele. .",
    "url": "http://localhost:4000/PMD_19-20/docs/segundo_trimestre_android/2019-12-03-asynctask/",
    "relUrl": "/docs/segundo_trimestre_android/2019-12-03-asynctask/"
  }
  ,"19": {
    "title": "Notificaciones",
    "content": "Para este ejemplo vamos a seguir paso a paso la documentación oficial de Android respecto a las notificaciones: . Página 1: https://developer.android.com/guide/topics/ui/notifiers/notifications?hl=es-419 | Página 2: https://developer.android.com/training/notify-user/build-notification?hl=es-419 | Página 3: https://developer.android.com/training/notify-user/expanded?hl=es-419 | . Revisa la documentación antes de continuar. En el ejemplo se ha separado cada tipo de notificación en un botón diferente. . Creación del canal de notificaciones . private void createNotificationChannel() { // Create the NotificationChannel, but only on API 26+ because // the NotificationChannel class is new and not in the support library if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) { CharSequence name = getString(R.string.channel_name); String description = getString(R.string.channel_description); int importance = NotificationManager.IMPORTANCE_DEFAULT; NotificationChannel channel = new NotificationChannel(CHANNEL_ID, name, importance); channel.setDescription(description); // Register the channel with the system; you can&#39;t change the importance // or other notification behaviors after this NotificationManager notificationManager = getSystemService(NotificationManager.class); notificationManager.createNotificationChannel(channel); } } . Este canal de notificaciones es obligatorio únicamente a partir del API 26, por lo que la primera línea que tenemos al intentar crearlo es ` if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) { … }` . Por lo tanto si la versión es inferior no es necesario la creación de este canal. . El canal deberá de tener un CHANNEL_ID único, que habrá que tener en cuenta cuando creemos la notificación. Una vez configurados todos los parámetros se creará el canal con notificationManager.createNotificationChannel(channel) . Notificación básica . NotificationCompat.Builder builder = new NotificationCompat.Builder(this, CHANNEL_ID) .setSmallIcon(R.drawable.ic_android_black_24dp) // el icono debe de ser en gama de blancos y negros .setContentTitle(&quot;Título&quot;) .setContentText(&quot;Contenido&quot;) .setPriority(NotificationCompat.PRIORITY_DEFAULT); // Mostramos la notificación NotificationManagerCompat notificationManager = NotificationManagerCompat.from(this); // notificationId is a unique int for each notification that you must define notificationManager.notify(1, builder.build()); . A tener en cuenta: . Se debe haber creado anteriormente el canal, y utilizar esa ID para crear la notificación (CHANNEL_ID). | Para que se muestre el icono correctamente debe de tener un canal alfa. El icono se mostrará en blanco y negro, pero podemos cambiar el color mediante: | . builder.setColor(ContextCompat.getColor(context, R.color.colorPrimary)) . El requestCode en notify() debe de ser único para cada notificación. En caso contrario se irán agrupando. | . Notificación con acción toque a una actividad . // Intent explícito hacia una actividad Intent intent = new Intent(this, Main2Activity.class); intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK); PendingIntent pendingIntent = PendingIntent.getActivity(this, 0, intent, 0); NotificationCompat.Builder builder = new NotificationCompat.Builder(this, CHANNEL_ID) .setSmallIcon(R.drawable.ic_android_black_24dp) .setContentTitle(&quot;My notification&quot;) .setContentText(&quot;Hello World!&quot;) .setPriority(NotificationCompat.PRIORITY_DEFAULT) // Set the intent that will fire when the user taps the notification .setContentIntent(pendingIntent) .setAutoCancel(true); // Mostramos la notificación NotificationManagerCompat notificationManager = NotificationManagerCompat.from(this); // notificationId is a unique int for each notification that you must define notificationManager.notify(2, builder.build()); . Cambios respecto a la notificación básica: . Utilización de PendingIntent https://developer.android.com/reference/android/app/PendingIntent, https://android.jlelse.eu/intent-vs-pendingintent-8ef2ad5824ed. | . Con botón de acción . Intent snoozeIntent = new Intent(this, Main2Activity.class); snoozeIntent.setAction(&quot;Botón&quot;); snoozeIntent.putExtra(&quot;extra&quot;, 0); PendingIntent snoozePendingIntent = PendingIntent.getActivity(this, 0, snoozeIntent, 0); NotificationCompat.Builder builder = new NotificationCompat.Builder(this, CHANNEL_ID) .setSmallIcon(R.drawable.ic_android_black_24dp) .setContentTitle(&quot;My notification&quot;) .setContentText(&quot;Hello World!&quot;) .setPriority(NotificationCompat.PRIORITY_DEFAULT) .addAction(R.drawable.ic_android_black_24dp, &quot;Botón&quot;, snoozePendingIntent) // podemos añadir hasta 3 botones, en este caso botón 2 utiliza el mismo pending intent, // por lo que tendrá la misma funcionalidad de botón 1 .addAction(R.drawable.ic_android_black_24dp, &quot;Botón2&quot;, snoozePendingIntent); // Mostramos la notificación NotificationManagerCompat notificationManager = NotificationManagerCompat.from(this); // notificationId is a unique int for each notification that you must define notificationManager.notify(3, builder.build()); . Cambios respecto a la acción con toque: . Observa la instancia de intent y la llamada a .addAction(). | . Acción con respuesta directa . En este caso debemos incluir también código en la actividad que recibe el mensaje. . 1. Creación de la notificación: . RemoteInput remoteInput = new RemoteInput.Builder(KEY_TEXT_REPLY) .setLabel(&quot;Etiqueta1&quot;) .build(); // Build a PendingIntent for the reply action to trigger. Intent intent = new Intent(this, Main3Activity.class); //intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK); PendingIntent pendingIntent = PendingIntent.getActivity(this, 0, intent, 0); // Create the reply action and add the remote input. NotificationCompat.Action action = new NotificationCompat.Action.Builder(R.drawable.ic_android_black_24dp, &quot;Etiqueta2&quot;, pendingIntent) .addRemoteInput(remoteInput) .build(); NotificationCompat.Builder builder = new NotificationCompat.Builder(this, CHANNEL_ID) .setSmallIcon(R.drawable.ic_android_black_24dp) .setContentTitle(&quot;My notification&quot;) .setContentText(&quot;Hello World!&quot;) .setPriority(NotificationCompat.PRIORITY_DEFAULT) .addAction(action) .setAutoCancel(true); // Issue the notification. NotificationManagerCompat notificationManager = NotificationManagerCompat.from(this); notificationManager.notify(4, builder.build()); . 2. Código de la actividad receptora: . public class Main3Activity extends AppCompatActivity { private static final String KEY_TEXT_REPLY = &quot;key_text_reply&quot;; static final String CHANNEL_ID = &quot;ID_CANAL&quot;; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main3); String mensaje = getMessageText(getIntent()).toString(); Toast.makeText(this, mensaje, Toast.LENGTH_SHORT).show(); // Build a new notification, which informs the user that the system // handled their interaction with the previous notification. NotificationCompat.Builder builder = new NotificationCompat.Builder(this, CHANNEL_ID) .setSmallIcon(R.drawable.ic_android_black_24dp); // Issue the new notification. NotificationManagerCompat notificationManager = NotificationManagerCompat.from(this); notificationManager.notify(4, builder.build()); } private CharSequence getMessageText(Intent intent) { Bundle remoteInput = RemoteInput.getResultsFromIntent(intent); if (remoteInput != null) { return remoteInput.getCharSequence(KEY_TEXT_REPLY); } return null; } } Es en el método `getMessageText()` donde se recupera el mensaje. Además, se debe de devolver un `notify()` a la notificación con una id concreta para responder. . Cambios respecto a las notificaciones anteriores: . Utilización de la clase RemoteInput. | Notification.Action.Builder().addRemoteInput().build() | Debemos de recibir el mensaje y responder. | . Barra de progreso . Es una notificación más simple que las anteriores. La dividiremos en varias partes. . 1. Creación: . public void notifiacionBarra(View v) { notificationManagerProgreso = NotificationManagerCompat.from(this); builderProgreso = new NotificationCompat.Builder(this, CHANNEL_ID); builderProgreso.setContentTitle(&quot;Picture Download&quot;) .setContentText(&quot;Download in progress&quot;) .setSmallIcon(R.drawable.ic_android_black_24dp) .setPriority(NotificationCompat.PRIORITY_LOW); // Issue the initial notification with zero progress int PROGRESS_MAX = 100; int PROGRESS_CURRENT = 0; builderProgreso.setProgress(PROGRESS_MAX, PROGRESS_CURRENT, false); notificationManagerProgreso.notify(5, builderProgreso.build()); } . 2. Aumentar la barra de progreso: . public void notificacionUp(View v) { // Si estamos por debajo del máximo if (PROGRESS_CURRENT &lt; PROGRESS_MAX) { builderProgreso.setProgress(PROGRESS_MAX, PROGRESS_CURRENT += 10, false); notificationManagerProgreso.notify(5, builderProgreso.build()); } // Si llegamos al máximo else { builderProgreso.setContentText(&quot;Download complete&quot;) .setProgress(0, 0, false); notificationManagerProgreso.notify(5, builderProgreso.build()); } } . 3. Disminuir la barra de progreso: . public void notificacionDown(View v) { builderProgreso.setProgress(PROGRESS_MAX, PROGRESS_CURRENT-=10, false); notificationManagerProgreso.notify(5, builderProgreso.build()); } . Proyecto GitHub: https://github.com/Manuel-Ag/PMD_19-20/tree/master/Notificaciones | .",
    "url": "http://localhost:4000/PMD_19-20/docs/segundo_trimestre_android/2019-12-05-notificaciones/",
    "relUrl": "/docs/segundo_trimestre_android/2019-12-05-notificaciones/"
  }
  ,"20": {
    "title": "Lectura fichero directorio raw",
    "content": "En el directorio raw, según la documentación oficial de Android se utiliza para almacenar: . Archivos arbitrarios para guardar sin procesar. Para abrir estos recursos con un objeto InputStream sin procesar, llama a Resources.openRawResource() con el ID del recurso, que es R.raw.filename. | . . Hay que tener en cuenta que los ficheros alojados en este directorio son de solo lectura. En este ejemplo leemos de un fichero de texto la información contenida en él. . Proyecto GitHub: https://github.com/Manuel-Ag/PMD_19-20/tree/master/Ficheros | . La única diferencia con la lectura de cualquier otro fichero es la forma en la que se accede al recurso: . InputStream inputStream = this.getResources().openRawResource(R.raw.fichero); . Una vez tengamos el objeto inputStream podremos leer de él como mejor nos convenga. . InputStreamReader inputreader = new InputStreamReader(inputStream); BufferedReader bufferedReader = new BufferedReader(inputreader); String line; while ((line = bufferedReader.readLine()) != null) { Log.i(&quot;debug&quot;, line); } .",
    "url": "http://localhost:4000/PMD_19-20/docs/segundo_trimestre_android/2019-12-12-ficheros/",
    "relUrl": "/docs/segundo_trimestre_android/2019-12-12-ficheros/"
  }
  ,"21": {
    "title": "Alarmas",
    "content": "En este ejemplo se establecerá una alarma en el dispositivo Android que se lanzará dependiendo de la especificación del usuario. La clase que utilizaremos será AlarmManager y el componente que recibirá la alerta será un BroadcastReceiver. . . Primeramente, se recuperan los valores introducidos por el usuario a la que se programa la alarma. Recuperamos las variables y creamos un objeto de tipo Calendar. Esta clase nos ayudará a convertir la hora y minutos a milisegundos. . Calendar calendar = Calendar.getInstance(); calendar.set(Calendar.HOUR_OF_DAY, Integer.parseInt(editTextHora.getText().toString())); calendar.set(Calendar.MINUTE, Integer.parseInt(editTextMin.getText().toString())); calendar.set(Calendar.SECOND, 0); . A continuación, al igual que hicimos con las notificaciones, definimos un PendingIntent especificando que será un componente de tipo BroadcastReceiver quien lo reciba (podría ser otro componente diferente). Además, pasamos como parámetro el intent explícito hacia la clase donde queremos enviarlo. . Intent intent = new Intent(this, Alarma.class); pendingIntent = PendingIntent.getBroadcast(this, 0, intent, 0); . Por último, se establece la alarma a través de un objeto de la clase AlarmManager. . // Se crea la instancia de AlarmManager AlarmManager alarmManager = (AlarmManager) this.getSystemService(this.ALARM_SERVICE); // Se lanzará de forma inexacta alarmManager.setInexactRepeating(AlarmManager.RTC_WAKEUP, calendar.getTimeInMillis(), AlarmManager.INTERVAL_DAY, pendingIntent); . Esta es una forma de crear una alarma inexacta, la cual puede retrasarse algunos segundos. Es un tipo de alarma que consume menos batería que una exacta. Es la recomendable si no necesitamos que se lance justo en el tiempo especificado. . No hay que olvida que, si es un componente propio el que recibirá la alarma como es el caso, también debemos programarlo. . public class Alarma extends BroadcastReceiver { @Override public void onReceive(Context context, Intent intent) { Toast.makeText(context, &quot;Alarma&quot;, Toast.LENGTH_SHORT).show(); Log.i(&quot;prueba&quot;, &quot;alarma lanzada&quot;); } } . Es un sencillo BroadcastReceiver como los creados en temas anteriores. . Proyecto GitHub: https://github.com/Manuel-Ag/PMD_19-20/tree/master/Alarmas | .",
    "url": "http://localhost:4000/PMD_19-20/docs/segundo_trimestre_android/2019-12-17-Alarmas/",
    "relUrl": "/docs/segundo_trimestre_android/2019-12-17-Alarmas/"
  }
  ,"23": {
    "title": "",
    "content": "",
    "url": "http://localhost:4000/PMD_19-20/",
    "relUrl": "/"
  }
  ,"24": {
    "title": "Primer trimestre Android",
    "content": "Primer trimestre Android .",
    "url": "http://localhost:4000/PMD_19-20/docs/primer_trimestre_android",
    "relUrl": "/docs/primer_trimestre_android"
  }
  ,"25": {
    "title": "Segundo trimestre Android",
    "content": "Segundo trimestre Android .",
    "url": "http://localhost:4000/PMD_19-20/docs/segundo_trimestre_android",
    "relUrl": "/docs/segundo_trimestre_android"
  }
  
}